FAST FLUID DYNAMICS SIMULATION ON THE GPU

Questo capitolo descrive un metodo per una simulazione veloce, stabile di fluido dinamica che gira completamente sulla GPU. Viene introdotta la fluido dinamica e la matematica associata, e viene descritta in dettaglio le tecniche per portare a termine la simulazione sulla GPU. 

INTRODUZIONE

I Fluidi sono dappertutto: acqua che passa tra le sponde di un fiume, il fumo che si arriccia da una sigaretta accesa, il vapore che esce da una teiera, vapore acqueo che si forma in nuvole e vernice che viene mescolata in un barattolo. Alla base di tutti c'è il flusso dei fluidi. Tutti sono fenomeni che sarebbe interessante rappresentare realisticamente in applicazioni grafiche interattive. [FIGURA]

La simulazione dei fluidi è un utile mattone che è la base per simulare una varietà di fenomeni naturali. A causa dell'elevata presenza di parallelismo nell'hardware grafico, la simulaizone descritta gira molto più velocemente sulla GPU che sulla CPU. % POSSIBILE SPEEDUP ?

@inbook{10.1145/3596711.3596793,
author = {Stam, Jos},
title = {Stable Fluids},
year = {2023},
isbn = {9798400708978},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
edition = {1},
url = {https://doi.org/10.1145/3596711.3596793},
abstract = {Building animation tools for fluid-like motions is an important and challenging problem with many applications in computer graphics. The use of physics-based models for fluid flow can greatly assist in creating such tools. Physical models, unlike key frame or procedural based techniques, permit an animator to almost effortlessly create interesting, swirling fluid-like behaviors. Also, the interaction of flows with objects and virtual forces is handled elegantly. Until recently, it was believed that physical fluid models were too expensive to allow real-time interaction. This was largely due to the fact that previous models used unstable schemes to solve the physical equations governing a fluid. In this paper, for the first time, we propose an unconditionally stable model which still produces complex fluid-like flows. As well, our method is very easy to implement. The stability of our model allows us to take larger time steps and therefore achieve faster simulations. We have used our model in conjuction with advecting solid textures to create many fluid-like animations interactively in two- and three-dimensions.},
booktitle = {SemiEquation 2, the continuity equation, enforces the incompressibility assumption by ensuring that the fluid always has zero divergence. The dot product in the divergence operator results in a sum of partial derivatives (rather than a vector, as with the gradient operator). This means that the divergence operator can be applied only to a vector field, such as the velocity, u = (u, v).nal Graphics Papers: Pushing the Boundaries, Volume 2},
articleno = {81},
numpages = {8}
}

@inproceedings{10.1145/311535.311548,
author = {Stam, Jos},
title = {Stable fluids},
year = {1999},
isbn = {0201485605},
publisher = {ACM Press/Addison-Wesley Publishing Co.},
address = {USA},
url = {https://doi.org/10.1145/311535.311548},
doi = {10.1145/311535.311548},
abstract = {Building animation tools for fluid-like motions is an important and challenging problem with many applications in computer graphics. The use of physics-based models for fluid flow can greatly assist in creating such tools. Physical models, unlike key frame or procedural based techniques, permit an animator to almost effortlessly create interesting, swirling fluid-like behaviors. Also, the interaction of flows with objects and virtual forces is handled elegantly. Until recently, it was believed that physical fluid models were too expensive to allow real-time interaction. This was largely due to the fact that previous models used unstable schemes to solve the physical equations governing a fluid. In this paper, for the first time, we propose an unconditionally stable model which still produces complex fluid-like flows. As well, our method is very easy to implement. The stability of our model allows us to take larger time steps and therefore achieve faster simulations. We have used our model in conjuction with advecting solid textures to create many fluid-like animations interactively in two- and three-dimensions.},
booktitle = {Proceedings of the 26th Annual Conference on Computer Graphics and Interactive Techniques},
pages = {121–128},
numpages = {8},
keywords = {Navier-Stokes, advected textures, animation of fluids, gaseous phenomena, implicit elliptic PDE solvers, interactive modeling, stable solvers},
series = {SIGGRAPH '99}
}

Mentre le simulazioni di Stam sono implementate nella CPU, si è scelto di implementare questo algoritmo nell'hardware grafico perché le GPU sono ben equipaggiate per gestire le computazioni nececessarie per la simulaizone dei fluidi. La simulazione descritta è svolta in una griglia di celle. Le GPU programmabili sono ottimizzate per computazioni sui pixel, che si possono considerare come griglia di celle. Le GPU riescono ad arrivare ad alte performance grazie al parallelismo: sono capaci di processare simultaneamente diversi vertici e pixel. Sono anche ottimizzate per eseguire più ricerche di texture per ciclo. Poiché le griglie della simulazione sono memorizzate in textures, questa velocità e parallelismo è proprio quello che serve.

Si restringe l'argomento a una simulazione di un volume continuo di un fluido in un dominio rettangolare bidimensionale. Inoltre, non vengno simulate i confini della superficie libera tra i fluidi, come l'interfaccia tra acqua e aria in movimento. Ci sono molte estensioni a queste tecniche basilari. Vengono menzionate una parte di queste tecniche alla fine del capitolo. [METTERE REFERENCES]

Tutti i vettori in questo capitolo vengono assunti come bidimensionali

[METTERE INTRODUZIONE A OGNI CAPITOLO E BREVE DESCRIZIONE]



BACKGROUND MATEMATICO
Per simulare il comportamento di un fluido, si deve avere una rappresentazione matematica dello stato del fluido in qualsiasi momento. La quantità più importante da rappresentare è la velocità del fluido, perché la velocità determina come il fludo muove se stesso e le cose al suo interno. La velocità del fluido varia sia nel tempo sia nello spazio, così viene rappresentato come un campo vettoriale.
Un campo vettoriale è una mappatura di una funzione vettoriale su uno spazio parametrizzato, come ad esempio una griglia cartesiana. (Sono possibili altre parametriizazioni spaziali, ma per gli scopi di questo capitolo assumiamo una griglia cartesiama bidimensionale). La velocità campo vettoriale del fludo è definita così che per ogni poszione \(\vec{x} = (x,y)\), c'è una velocità associata al tempo \(t\), \(\vec{u}(\vec{x},t) = (u(\vec{x},t), v(\vec{x},t), w(\vec{x},t))\) [FIGURA]
La chiave per la simulazione del fluido è prendere passi nel tempo, e ad ogni passo, determinare correttamente il corrente campo vettoriale della velocità. Una volta ottenuto il campo vettoriale, si possono fare cose interessanti con esso, come usarlo per muovere oggetti, densità di fumo, e altre quantità che possono essere mostrate nella applicazione.

L'EQUAZIONE DI NAVIER-STOKES PER FLUSSO INCOMPRIMIBILE
In Fisica, è comune fare assunzioni semplificative per modellare un fenomeno complesso. La simulazione dei fluidi non è una eccezione. Viene assunto un fluido incompribile ed omogeneo.
Un fluido è incomprimibile se il volume di qualsiasi sottoregione del fluido è costante nel tempo. Un fluido è omogeneo se la sua densità è costante nel tempo. La combinazione di incomprimibilità e omogeneità significa che la densità è costante sia nel tempo che nello spazio. Queste assunzioni sono comuni in fluido dinamica, e non decrementano il grado di applicabilità dei risultati matematici per la simulazione reale dei fluidi, come acqua e aria.
Viene simulato la fluido dinamica in una griglia cartesiana con coordinate spaziali \(\vec{x} = (x,y)\) e variabile temporale \(t\). Il fluido è rappresentato dal suo campo vettoriale della velocità \(\vec{u}(\vec{x},t)\), come descritto precedentemente, e dalla funzione scalare della pressione \(p(\var{x},t)\). Questi campi variano sia nello spazio che nel tempo. Se la velocità e la pressione sono note per l'istante iniziale \(t=0\), allora lo stato del fluido nel tempo può essere descritto dalla \emph{equazione di Navier-Stokes per un flusso incomprimibile:
\begin{align*}
	\frac{\partial \vec{u}}{\partial t} &= - (\vec{u} \bullet \nabla) \vec{u} - \frac{1}{\rho} \nabla p + \nu \nabla^2 \vec{u} + \var{F} \\
	\nabla \bullet \vec{u} = 0
\end{align*}
dove \(\rho\) è la (costante) densità del fluido, \(\nu\) è la viscosità dinamica, e \(\vec{F} = (f_x,f_y)\) rappresenta le forze esterne che agiscono sul fluido. Si noti che la prima equazione è in realtà due equazioni, perché \(\vec{u}\) è un vettore:

\begin{align*}
	\frac{\partial u}{\partial t} &= - (\vec{u} \bullet \nabla) u - \frac{1}{\rho} \frac{\partial p}{\partial x} + \nu \nabla^2 u + f_x \\
	\frac{\partial v}{\partial t} &= - (\vec{u} \bullet \nabla) v - \frac{1}{\rho} \frac{\partial p}{\partial y} + \nu \nabla^2 v + f_y
\end{align*}

Così, si hanno tre variabili sconosciute \((u, v \space \text{e} \space p)\) e tre equazioni.

TERMS IN THE NAVIER-STOKES EQUATIONS
Advection
La velocità di un fluido causa il trasporto di oggetti da parte del fluido, densità, e altre quantità insieme al flusso. Il colorante viene trasportato, o spinto in avanti (\emph{advected}), insieme al campo (di velocità) del fluido. Infatti, la velocità di un fluido trasporta se stessa proprio come trasporta il colorante. Il primo termine nella parte destra della prima equazione rappresenta questa \emph{self-advection} del campo di velocità e è chiamata il advection term.

Pressure
Poiché le molecole di un fluido possono muoversi l'una intorno all'altra, tendono a "schiacciarsi" e a "sbattere". Quando la forza è applicata al fluido, non viene propagata istantaneamente attraverso l'intero volume. Invece, le molecole vicine alla alla forza spingono quelle più lontane, e la pressione aumenta. Poiché la pressione è forza per unità di area, qualsiasi pressione nel fluido porta naturalmente ad accelerazione. Il secondo termine, chiamato pressure term, rappresenta questa accelerazione.

Diffusion
Dalla esperienza con fluidi reali, si sa che alcuni fluidi sono più "densi" di altri. Per esempio, la melassa e lo sciroppo d'acero scorrono lentamente, mentre l'alcol per sfregamento scorre rapidamente. Si dice che fluidi densi hanno una alta viscosità. La viscosità è una misura di quanto resistivo sia un fludo al flusso. Questa resistenza risulta nella diffusione di momento (e quindi di velocità), così il terzo termine viene chiamato diffusion term.

External Forces
Il quarto termine incapsula l'accelerazione che deriva da forze esterne applicate al fluido. Queste forze possono essere forze locali o forze di corpo. Le forze locali si applicano a una regione specifica del fluido, ad esempio la forza di un ventilatore che soffia aria. Le forze corporee, come la forza di gravità, si applicano uniformemente all'intero fluido.

@article{chorinmathematical,
  title={A Mathematical Introduction to Fluid Mechanics [electronic resource]},
  author={Chorin, Alexandre J and Marsden, Jerrold E and others},
  publisher={New York, NY: Springer US,}
}


A BRIEF REVIEW OF VECTOR CALCULUS
\(\nabla\) \(\to\) operatore \emph{nabla}. Le tre applicazioni del \emph{nabla} sono il gradiente, la divergenza, e gli operatori Laplaciani, come mostrato in [TABELLA]

Gradiente -> il gradiente di un campo scalare è un vettore di derivate parziali del campo scalare.

Divergenza -> appare nella equazione 2 ha un importante significato fisico. \`E la velocità con cui la "densità" esce da una determinata regione dello spazio. Nelle equazioni di Navier-Stokes, viene applicata alla velocità del flusso, e misura la variazione netta di velocità su una superficie che circonda un piccolo pezzo di fluido. La seconda equazione, la \emph{continuity equation}, fa valere l'ipotesi di incomprimibilità assicurando che il fluido abbia sempre divergenza zero. Il prodotto (dot product) nell'operatore di divergenza risulta in una somma di derivate parziali (anziché un vettore, come nel caso dell'operatore gradiente). Ciò significa che l'operatore di divergenza può essere applicato solo a un campo vettoriale, come la velocità \(\vec{u} = (u,v)\). Si noti che il gradiente di un campo scalare è un campo vettoriale, e la divergenza di un campo vettoriale è un campo scalare. 

Laplaciano -> Se l'operatore divergenza è applicato al risultato dell'operatore gradiente, il risultato è l'operatore Laplaciano \(\nabla \bullet \nabla = \nabla^2\). Se la celle della griglia sono quadrati (i.e., se \(dx = dy\), che si assume per il resto del capitolo), il Laplaciano si semplifica come: ...
L'operatore Laplaciano appare comunemente in fisica, soprattutto sotto forma di equazioni di diffusione, come l'equazione del calore. Le equazioni della forma \(\nabla^2x = b\) sono note come equazioni di Poisson. Il caso in cui \(b=0\) è l'equazione di Laplace, che è l'origine dell'operatore Laplaciano. Nell'equazione 1, il Laplaciano è applicato al un campo vettoriale. Questa è un abuso di notazione: l'operatore viene applicato separatamente a ogni componenete scalare del campo vettoriale.

SOLVING THE NAVIER-STOKES EQUATIONS
Le equazioni di Navier-Stokes possono essere risolte analiticamente solo per alcune semplici configurazioni fisiche. Tuttavia, è possibile usare tecniche di integrazione numerica per risolverle incrementalmente. Poiché si è interessati a guardare l'evoluzione del flusso nel tempo, una soluzione numerica incrementale potrebbe essere quella ottimale.

Come per ogni algoritmo, si deve dividere la soluzione delle equazioni di Navier-Stokes in passi semplici. Il metodo usato è basato su [STABLE FLUIDS - STAM 1999]. In questa sezione si descrive la matematica di ogni passo

Innanzitutto, si devono trasformare le equazioni in una forma più adatta alla soluzione numerica. Si ricordi che le equazioni di Navier-Stokes sono tre equazioni che si possono risolvere per le quantità \(u, v \space \text{e} \space p\). Tuttavia, non è ovvio come risolverle. La sezione seguente descrive una trasformazione che porta a un algoritmo semplice

THE HELMHOTZ-HODGE DECOMPOSITION
Calcolo vettoriale basilare dice che qualsiasi vettore \(\vec{v}\) può essere decomposto in un insieme di componenti vettoriali basilari la cui somma è \(\vec{u}\). Per esempio, si può comunemente rappresentare vettori in una griglia cartesiana come una coppia di distanze lungo gli assi della griglia: \(\vec{v} = (x,y)\). Lo stesso vettore può essere riscritto come \(\vec{v} = x \hat{i} + y \hat{j}\), dove \(\hat{i}\) e \(\hat{j}\) sono vettori unitari basici allineati agli assi della griglia.

Nello stesso modo in cui si può decomporre un vettore in una somma di vettori, si può anche decomporre un campo vettoriale in una somma di campi vettoriali. Sia \(D\) la regione dello spazio, o in questo ccaso del piano, in cui il fluido è definito. Inoltre, sia dato che questa regione abbia un confine liscio (cioè differenziabile), \(\partial D\), con direzione normale \(\vec{n}\). Si può usare il seguente teorema, come riportato in [CHORIN AND MARSDEN 1993].

Teorema:
Un campo vettoriale \(\vec{w}\) su \(D\) può essere decomposto unicamente nella forma:
\[
	\vec{w} = \vec{u} + \nabla p
\]
dove \(\vec{u}\) ha divergenza zero ed è parallelo a \(\partial D\); cioè \(\vec{u} \times \vec{n} = 0\) su \(\parial D\).

Si usa questo teorema senza dimostrazione. Per dettagli -> [CHORIN AND MARSDEN 1993]

Questo teorema afferma che qualsiasi campo vettoriale può essere decomposto nella somma di due altri campi vettoriali: un campo vettoriale privo di divergenza, e il gradiente di un campo scalare. Dice anche che il campo privo di divergenza si azzera al limite. \`E uno strumento potente, che porta a due utili realizzazioni.

Prima Realizzazione:
Risolvere le equazioni di Navier-Stokes comporta tre calcoli per aggiornare la velocità in ogni singolo punto: advection, diffusion, e la force application. Il risultato è un nuovo campo vettoriale della velocità, \(\vec{w}\), con divergenza non nulla. Ma l'equazione di continuità richiede che si finisca ogni passo con una velocità con divergenza nulla. Fortunatamente, il teorema della decomposizione di HELMHOLTZ-HODGE dice che la divergenza della velocità può essere corretta sottraendo il gradiente del campo vettoriale di pressione risultante: 
\[
	\vec{u} = \vec{w} - \nabla p
\]

Seconda Realizzazione:
Il teorema porta anche a un metodo per computare il campo della pressione. Applicando l'operatore divergenza ad entrambi i lati della equazione 7, si ottiene:
\[
	\nable \vec{w} = \nabla ( \vec{u} + \nabla p) = \nabla \vec{u} + \nabla^2 p
\]
Ma poiché l'equazione 2 (continuità) forza che \(\nabla \bullet \vec{u} = 0\), questa si semplifica a:
\[
	\nabla^2 p = \nabla \vec{w}
\]
che è una equazione di Poisson per la pressione del fluido, qualche volta chiamata anche \emph{Poisson-pressure equation}. Questa significa che dopo essere arrivati alla velocità divergente [LA VELOCITà è DIVERGENTE PERCHè SONO METODI NUMERICI -> ERRORI, NON SOLUZIONI ANALITICHE], si può risolvere l'equazione precedente (10) per \(p\), e dopo usare \(vec{w}\) e \(p\) per comutare la nuova non divergente campo \(\vec{u}\), usando equazione 8.

Ora serve un modo per computare \(\vec{w}\). Per farlo, si ritorni alla comparazione tra vettori e campi vettoriali. Dalla definizione di prodotto scalare, si sa che si può trovare la proiezione di un vettore \(\vec{r}\) su un vettore unità \(\hat{s}\) computando il prodotto scalare tra \(\vec{r}\) e \(\hat{s}\). Il prodotto scalare è un operatore di proiezione per vettori che mappa un vettore \(\vec{r}\) sulla sua componente in direzione di \(\hat{s}\). Si può usare il teorema di Helmholtz-Hodge Decomposition per definire l'operatore di proiezione, \(mathbb{P}\), che proietta un campo vettoriale \(\vec{w}\) nella sua componente senza divergenza \(\vec{u}\). Se applichiamo \(\mathbb{P}\) all'equazione 7, si ottiene:
\[
	\mathbb{P} \vec{w} = \mathbb{P} \vec{u} + \mathbb{P} ( \nabla p )
\]
Ma per definizione di \(mathbb{P}\), \(\mathbb{P} \vec{w} = \mathbb{P} \vec{u} = \vec{u}\). Quindi, \(\mathbb{P} ( \nabla p ) = 0\). Ora si usino queste idee per semplificare le equazioni di Navier-Stokes.

Prima, si applichi la proiezione ad entrambi i lati della equazione 1:
\[
	\mathbb{P} \frac{\partial \vec{u}}{\partial t} = \mathbb{P} \left ( - ( \vec{u} \bullet \nabla ) \vec{u} - \frac{1}{\rho} \nabla p + \nu \nabla^2 \vec{u} + \vec{F} \right )
\]
Poiché \(vec{u}\) ha divergenza nulla, così anche la derivata nella parte sinistra, quindi \(\mathbb{P} ( \frac{\partial \vec{u}}{\partial t} ) = \frac{\partial \vec{u}}{\partial t}\). Inoltre, \(\mathbb{P} ( \nabla p ) = 0\), quindi anche il termine pressure viene eliminato. Si rimane con la seguente equazione:
\[
	\frac{\partial \vec{u}}{\partial t} = \mathbb{P} \left ( - ( \vec{u} \bullet \nabla ) \vec{u} + \nu \nabla^2 \vec{u} + \vec{F} \right )
\]

La grande cosa di questa equazione è che incapsula simbolicamente l'intero algoritmo per simulare il flusso del fluido. Si deve prima computare quello all'interno delle parentesi nella parte destra dell'equazione. Da sinistra a destra, si computa l'advection, la diffusion, e il termine delle forze esterne. L'applicazione di questi tre passaggi produce un campo di velocità divergente \(\vec{w}\), al quale poi si applica l'operatore di proiezione per ottenere un nuovo campo con divergenza nulla \(\vec{u}\). Per fare questo, si deve risolvere l'equazione 10 [\nabla^2 p = \nabla \vec{w}] per \(p\), e dopo sottrarre il gradiente di \(p\) da \(\vec{w}\), come nell'equazione 8.

In una implementazione tipica, i vari componenti non sono computati e sommati insieme, come nell'equazione 11. Invece, la soluzione è ottenuta attraverso la composizione di trasformazioni sullo stato; in altre parole, ogni componente è un passo che prende un campo come input e produce un nuovo campo come output. Si può definire un operatore \(mathbb{S}\) che è l'equivalente alla soluzione dell'equazione 11 su un singolo passo temporale. L'operatore è definito come la composizione di operatori di advection (\mathbb{A}\), diffusion (\(\mathbb{D}\)), force application (\(\mathbb{F}\)), e proiezione (\(\mathbb{P}\)):
\[
	\mathbb{S} = \mathbb{P} \circ \mathbb{F} \circ \mathbb{D} \circ \mathbb{A}
\]

Così, un passo dell'algoritmo di simulazione può essere espresso \(\mathbb{S}(\vec{u}) = \mathbb{P} \circ \mathbb{F} \circ \mathbb{D} \circ \mathbb{A}(\vec{u})\). Gli operatori sono applicati da destra a sinistra; prima advection, seguita da diffusion, force application, e proiezione. Si noti che il tempo è stato omesso per chiarezza, ma in pratica, il passo temporale deve essere utilizzato nel calcolo di ogni operatore. Ora si guardi più attentamente ai passi di advection e diffusion, per poi avvicinarsi alla soluzione delle equazioni di Poisson.

Advection
Advection è il processo per cui la velocità di un fluido trasporta se stessa e altre quantità nel fluido. Per computare l'advection di una quantità, si deve aggiornare la quantità in ogni punto della griglia. Poiché si sta computando come una quantità si muove lungo il campo di velocità, è utili immaginare che ogni cella della griglia sia rappresentata da una particella. Un primo tentativo di calcolare il risultato dell'advection potrebbe essere quello di aggiornare la griglia come si farebbe con un sistema di particelle. Basta spostare la posizione, \(\vec{r}\), di ogni particella in avanti lungo il campo di velocità per la distanza che percorrerebbe nel tempo \(\delta t\):
\[
	\vec{r}(t + \delta t) = \vec{r}(t) + \vec{u}(t) \delta t
\]
Si può riconoscere questa come il metodo di Eulero; è un semplice metodo per l'integrazione esplicita (o in avanti) delle equazioni differenziali ordinarie (ODE). (Esistono metodi più accurati, come il metodo dei punti medi e i metodi di Runge-Kutta).

Ci sono due problemi con questo approccio: il primo è che le simulazione che usano metodi espliciti per l'advection sono instabili per per passi temporali elevati e possono "esplodere" se la grandezza di \(vec{u}(t) \delta t\) è superiore alla dimensione di una singola cella della griglia. Il secondo problema è specifico dell'implementazione su GPU. L'algoritmo viene implementato in programmi a frammenti, che non possono cambiare le posizioni dei frammenti che stanno scrivendo. Questo metodi di integrazione in avanti richiede la capacità di "muovere" le particelle, quindi non può essere implementato sulle GPU attuali. [VEDERE SE GPU DI ADESSO POSSONO IMPLEMENTARLO]

La soluzione è quella di invertire il problema e usare un metodo implicito (STAM 1999). Piuttosto che aggiornare le quantità calcolando dove si muove una particella nel passo temporale corrente, si traccia la traiettoria delle particella da ogni cella della griglia a ritroso nel tempo fino alla sua posizione precedente, e si copiano le quantità in quella posizione nella cella della griglia di partenza. Per aggiornare una quantità \(q\) (questa potrebbe essere la velocità, densità, temperatura, o qualsiasi altra quantità trasportata dal fluido), e si usa la equazione seguente:
\[
	q(\vec{x}, t + \delta t) = q(\vec{x} - \vec{u}(\vec{x}, t) \delta t, t)
\]
Non solo si può implementare facilmente questo metodo nella GPU, ma come STAM ha mostrato, è stabile per passi temporali e velocità arbitrari. [FIGURA] mostra la computazione dell'advection nella cella marchiata con un doppio cerchio. Tracciare il campo di velocità all'indietro nel termpo porta al vettore posizione \(\vec{x}\) verde. I quattro valori della griglia più vicini al \(\vec{x}\) verde (connessi da un quadrato verde nella figura) sono interpolati bilinearmente, e il risultato è scritto nella cella di partenza.

Viscous Diffusion
Come spiegato prima, i fluidi viscosi hanno una certa resistenza al flusso, che risulta nella diffusione (o dissipazione) di velocità. Una equazione a derivate parziali per la diffusione viscosa è:
\[
	\frac{\partial \vec{u}}{\partial t} = \nu \nabla^2 \vec{u}
\]
Come nella advection, si può scegliere come risolvere questa equazione. Un approccio ovvio è formula una forma esplicita e discreta per sviluppare un semplice algoritmo:
\[
	\vec{u}(\vec{x}, t + \delta t) = \vec{u}(\vec{x}, t) + \nu \delta t \nabla^2 \vec{u}(\vec{x}, t)
\]
In questa equazione, \(\nabla^2\) è la forma discreta dell'operatore Laplaciano, equazione 3. Come il metodo esplicito di Eulero per la computazione dell'advection, questo metodo è instabile per grandi valori di \(\delta t\) e \(\nu\). Si segue ancora una volta l'esempio di Stan e si utlizza una formulazione implicita dell'equazione 14:
\[
	\(I - \nu \delta t \nabla^2) \vec{u}(\vec{x}, t + \delta t) = \vec{u}(\vec{x}, t)
\]
dove \(I\) è la matrice identità. Questa formulazione è stabile per passi temporali e viscosità arbitrarie. Questa equazione è un'equazione di Poisson (un po' mascherata) per la velocità. Si ricordi che l'uso della decomposizione di Helmholtz-Hodge si traduce in un'equazione di Poisson per la pression, Queste equazione possono essere risoltre con una tecnica di rilassamento iterativo.

Solution of Poisson Equations
Si devono risolvere due equazioni di Poisson: la \emph{Poisson pressure equation} e la \emph{viscous diffusion equation}. Le equazioni di Poisson sono comuni in fisica e ben comprese. Si utilizza una tecnica di soluzione iterativa che parte da una soluzioni approssimativa e la migliora a ogni iterazione. 

L'equazione di Poisson è una equazione matriciale della forma \(A \vec{x} = \vec{b}\), dove \(\vec{x}\) è il vettore dei valori per cui si sta risolvendo (\(p\) o \(\vec{u}\) in questo caso), \(\vec{b}\) è un vettore di costanti, e \(A\) è una matrice. In questo caso, \(A\) è semplicemente rappresentata dall'operatore Laplaciano \(\nabla^2\), quindi non deve essere necessariamente memorizzato come matrice. La tecnica di soluzione iterativa che si utilizza parte da una "ipotesi" iniziale per la soluzione \(\vec{x}^{(0)}\), e ogni passo \(k\) produce una soluzione migliore \(\vec{x}^{(k)}\). La notazione in apici indica il numero di iterazioni. La tecnica più iterativa più semplice è chiamata iterazione di Jacobi. Una derivazione dell'iterazione di Jacobi per le equazioni matriciali generali si trova in [GOLUB AND VAN LOAN 1996]

@book{golub2013matrix,
  title={Matrix computations},
  author={Golub, Gene H and Van Loan, Charles F},
  year={2013},
  publisher={JHU press}
}

Metodi più sofisticati, come il gradiente coniugato e i metodi multigriglia, convergono più velocemente, ma si è deciso di utilizzare il metodo di Jacobi per la sua semplicità e la facilità di implementazione. Per dettagli ed esempi di risolutori più sofisticati, si veda [BOLZ ET AL. 2003] [GOODNIGHT ET AL. 2003] [KRUGER E WESTERMANN 2003]

@article{10.1145/882262.882364,
author = {Bolz, Jeff and Farmer, Ian and Grinspun, Eitan and Schr\"{o}der, Peter},
title = {Sparse matrix solvers on the GPU: conjugate gradients and multigrid},
year = {2003},
issue_date = {July 2003},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {22},
number = {3},
issn = {0730-0301},
url = {https://doi.org/10.1145/882262.882364},
doi = {10.1145/882262.882364},
abstract = {Many computer graphics applications require high-intensity numerical simulation. We show that such computations can be performed efficiently on the GPU, which we regard as a full function streaming processor with high floating-point performance. We implemented two basic, broadly useful, computational kernels: a sparse matrix conjugate gradient solver and a regular-grid multigrid solver. Real time applications ranging from mesh smoothing and parameterization to fluid solvers and solid mechanics can greatly benefit from these, evidence our example applications of geometric flow and fluid simulation running on NVIDIA's GeForce FX.},
journal = {ACM Trans. Graph.},
month = jul,
pages = {917–924},
numpages = {8},
keywords = {numerical simulation, multigrid, mesh smoothing, fluid simulation, conjugate gradient, Navier-Stokes, GPU computing}
}

@inproceedings{10.1145/1198555.1198784,
author = {Goodnight, Nolan and Woolley, Cliff and Lewin, Gregory and Luebke, David and Humphreys, Greg},
title = {A multigrid solver for boundary value problems using programmable graphics hardware},
year = {2005},
isbn = {9781450378338},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/1198555.1198784},
doi = {10.1145/1198555.1198784},
abstract = {We present a case study in the application of graphics hardware to general-purpose numeric computing. Specifically, we describe a system, built on programmable graphics hardware, able to solve a variety of partial differential equations with complex boundary conditions. Many areas of graphics, simulation, and computational science require efficient techniques for solving such equations. Our system implements the multigrid method, a fast and popular approach to solving large boundary value problems. We demonstrate the viability of this technique by using it to accelerate three applications: simulation of heat transfer, modeling of fluid mechanics, and tone mapping of high dynamic range images. We analyze the performance of our solver and discuss several issues, including techniques for improving the computational efficiency of iterative grid-based computations for the GPU.},
booktitle = {ACM SIGGRAPH 2005 Courses},
pages = {193–es},
location = {Los Angeles, California},
series = {SIGGRAPH '05}
}

@inproceedings{10.1145/1198555.1198795,
author = {Kr\"{u}ger, Jens and Westermann, R\"{u}diger},
title = {Linear algebra operators for GPU implementation of numerical algorithms},
year = {2005},
isbn = {9781450378338},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/1198555.1198795},
doi = {10.1145/1198555.1198795},
abstract = {In this work, the emphasis is on the development of strategies to realize techniques of numerical computing on the graphics chip. In particular, the focus is on the acceleration of techniques for solving sets of algebraic equations as they occur in numerical simulation. We introduce a framework for the implementation of linear algebra operators on programmable graphics processors (GPUs), thus providing the building blocks for the design of more complex numerical algorithms. In particular, we propose a stream model for arithmetic operations on vectors and matrices that exploits the intrinsic parallelism and efficient communication on modern GPUs. Besides performance gains due to improved numerical computations, graphics algorithms benefit from this model in that the transfer of computation results to the graphics processor for display is avoided. We demonstrate the effectiveness of our approach by implementing direct solvers for sparse matrices, and by applying these solvers to multi-dimensional finite difference equations, i.e. the 2D wave equation and the incompressible Navier-Stokes equations.},
booktitle = {ACM SIGGRAPH 2005 Courses},
pages = {234–es},
keywords = {graphics hardware, numerical simulation},
location = {Los Angeles, California},
series = {SIGGRAPH '05}
}

Equazioni 10 e 15 appaiono diverse, ma entrambe possono essere discretizzate usando equazione 3 e riscritte nella forma:
\[
	\vec{x}_{i,j}^{(k+1)} = \frac{\vec{x}_{i-1,j}^{(k)} + \vec{x}_{i+1,j}^{(k)} + \vec{x}_{i,j-1}^{(k)} + \vec{x}_{i,j+1}^{(k)} + \alpha b_{i,j}}{\beta}
\]
dove \(\alpha\) e \(\beta\) sono costanti. I valori di \(\vex{x}, b, \alpha\) e \(\beta\) sono diversi per le due equazioni. Nella \emph{Poisson-pressure equation}, \(x\) rappresenta \(p\), \(b\) rappresenta \(\nabla \bullet \vec{w}\), \(\alpha = -(\delta x)^2\), e \(\beta = 4\). Per la \emph{viscous diffusion equation}, sia \(x\) che \(b\) rappresentano \(\vec{u}\), \(\alpha = \frac{(\delta x)^2}{\nu \delta t}, e \(\beta = 4 + \alpha\).

Si formulano le equazioni in questo modo perché così si utilizza lo stesso codice per risolvere entrambe le equazioni. Per risolvere le equazioni, è sufficiente eseguire un certo numero di iterazioni in cui si applica l'equazione 16 a ogni cella della griglia, utilizzando i risultati dell'iterazione precedente come input per quella successiva (\vec{x}^{k+1} becomes \vec{x}^k\). Poiché l'iterazione di Jacobi converge lentamente, è necessario eseguire molte iterazioni. Fortunatamente, le iterazioni di Jacobi sono poco costose da eseguire sulla GPU, quindi si possono eseguire molte iterazioni in un tempo molto breve.

Initial and Boundary Conditions
Qualsiasi problema che riguarda una equazione differenziale definito su un dominio finito richiede condizioni al contorno per essere ben posto. Le condizioni al contorno determinano come calcolare i valori ai bordi del dominio di simulazione. Inoltre, per calcolare l'evoluzione del flusso nel tempo, si deve sapere come è iniziato, ovvero le sue condizioni iniziali. Per questa simulazione di fluidi, si assume che il fluido abbia inizialmente velocità zero e pressione zero ovunque. Le condizioni al contorno richieddono una discussione più approfondita.

Durante ogni passo temporale, si risolvono le equazioni per due quantità - velocità e pressione - e servono condizioni al contorno per entrambe. Poiché il fluido è simulato con una griglia rettangolare, si assume che sia un fluido in una scatola e che non possa scorrere attraverso i lati della scatola. Per la velocità, si usa la \emph{no-slip condition}, che specifica che la velocità va a zero ai confini. La soluzione corretta della \emph{Poisson-pressure equation} richiede le condizioni al limite \emph{pure Neumann}: \(\frac{\partial p}{\partial \vec{n}} = 0\). Questa significa che in corrispondenza di un confine, il tasso di variazione della pressione nella direzione normale al confine è pari a zero. Le condizioni al contorno verranno riprese alla fine della sezione 38.3.


IMPLEMENTAZIONE
Ora che è stato capito il problema e le basi per risolverlo, si può procedere con l'implementazione. Un buon punto per iniziare è stendere pseudo-codice per l'algoritmo. L'algoritmo è lo stesso ad ogni passo, così lo pseudo-codice rappresenta un unico passo. Le variabili \(u\) e \(p\) contengono la velocità e la pressione.

[CODICE]

In pratica, è necessaria una memorizzazione temporanea, perché la maggior parte di queste operazioni non può essere eseguita in loco. Ad esempio, la fase di advection nello pseudocodice è più accuratamente scritta come:

[CODICE] -> 
uTemp = advect(u);
swap(u, uTemp);

Questo pseudocodice non contiene dettagli specifici della implementazione. Infatti, lo stesso pseudocodice descrive sia implementazioni per CPU sia per GPU. L'obiettivo è quello di eseguire tutti i passaggi sulla GPU. Questo tipo di calcolo su GPU potrebbe risultare poco familiare ad alcuni lettori, quindi si tracceranno alcune analogie tra le operazioni di una tipica simulazione di fluidi su CPU e le loro controparti su GPU.

CPU-GPU ANALOGIES
I modelli di memoria e di elaborazioni sono fondamentali per qualsiasi computer, quindi ogni applicazione deve tenere conto della rappresentazione dei dati e del calcolo. In questa sezione vengono analizzate le differenze tra CPU e GPU per quanto riguarda questi due aspetti

TEXTURES = ARRAYS
La (nostra) simulazione rappresenta i dati in una griglia bidimensionale. La naturale rappresentazione di questa griglia in una CPU è un array. L'analogo di un array in una GPU è una texture. Anche se le textures non sono flessibili come gli array, la loro flessibilità sta migliorando con l'evlozione dell'hardware grafico. Le texture nelle GPU correnti supportano tutte le operazioni basilari necessarie per implementare una simulazione di fluidi. Poiché le texture hanno di solito tre o quattro canali di colore, rappresentano una struttura di dati naturale per i tipi di dati vettoriali con due o quattro componenti. Alternativamente, molteplici campi scalari possono essere memorizzati in una singola texture. L'operazione più semplice è una lettura di un array (o di una memoria), che viene eseguita utilizzando una \emph{texture lookup}. Pertanto, l'analogo GPU di un offset di un array è una coordinata di texture. Si ha bisogno di almeno due texture per rappresentare lo stato del fluido: una per la velocità e una per la pressione. Per visualizzare il flusso, si mantiene una texture aggiuntiva che contiene una quantità trasportata dal fluido. Si può pensare a questa texture come a un "inchiostro". La [FIGURA] mostra esempi di queste texture, oltre a una texture aggiuntiva per la vorticità (\emph{vorticity}), descritta in sezione 38.5.1.

LOOP BODIES = FRAGMENT PROGRAMS
L'implementazione della simulazione da parte della CPU esegue le fasi dell'algoritmo mediante loop, utilizzando una coppia di loop annidati per iterare su ogni cella della griglia. In ogni cella viene eseguito lo stesso calcolo. Le GPU non sono in grado di eseguire questo ciclo interno su ogni texel di una texture. Tuttavia, la pipeline dei frammenti è progettata per eseguire calcoli identici in ogni frammento. Al programmatore sembra che ci sia un processore per ogni frammento e che tutti i frammenti vengano aggiornati simultaneamente. Nel linguaggio della programmazione parallela, questo modello è noto come calcolo a istruzioni singole e dati multipli (SIMD). Pertanto, l'analogo GPU del calcolo all'interno di loop annidati su un array è un programma a frammenti applicato in modo SIMD a ciascun frammento.

FEEDBACK = TEXTURE UPDATE
Nella sezione 38.2.4, è stato descritto come usare l'iterazione di Jacobi per risolvere le equazioni di Poisson. Questo tipo di metodo iterativo usa il risultato di una iterazione come input per la iterazione successiva. Questo \emph{feedback} è comune in tutti i metodi numerici. In una implementazione CPU, di solito il feedback non viene considerato, perché è banalmente implementato usando variabili e array che possono essere sia letti che scritti. Sulla GPU, invece, l'output dei processori di frammenti viene sempre scritto nel frame buffer. Si pensi il frame buffer come un array bidimensionale che non può essere letto direttamente. Esistono due modi per ottenere il contenuto del frame buffer in una texture leggibile:

Copy to texture (CTT) -> copia da un frame buffer a una texture
Render to texture (RTT) -> usa una texture come frame buffer, così la GPU può scriverci direttamente

CTT e RTT funzionanon ugualmente bene, ma hanno un compromesso in termini di prestazioni. Per motivi di generalità, non si assume l'uso di nessuno dei due e ci si riferisce al processo di scrittura su una texture come \emph{texture update}.

Precedentemente si è detto che, in pratica, ognuno dei cinque passi dell'algoritmo aggiorna una griglia temporanea e poi esegue uno swap. RTT richiede l'uso di due texture per implementare il feedback, perché i risultati del rendering su una texture mentre è vincolata alla lettura sono indefiniti. Lo swap in questo caso è semplicemente uno scambio di ID di texture. Il costo delle prestazioni di RTT è quindi costante. CTT, invece, richiede solo una texture. Il frame buffer funge da griglia temporanea e lo swap viene eseguito copiando i dati dal frame buffer alla texture. Il costo di questa copia è proporzionale alla dimensione della texture

SLAB OPERATIONS
Le fasi della simulazione sono suddivise in quelle che sono chimate \emph{slab operations} (slabop, in breve). Ogni slabop consiste nell'elaborazione di uno o più (spesso tutti) frammenti nel frame buffer, di solito con un programma di frammenti attivo, seguito da un aggiornamento delle texture. Per questa applicazione, la geometria che si renderizza è semplice: solo primitive quad e line.

Ci sono due tipi di frammenti da elaborare in qualsiasi slabop: frammenti interni e frammenti confine. La griglia 2D riserva un perimetro di una singola cella per memorizzare e calcolare le condizioni al contorno. In genere, viene eseguito un calcolo diverso all'interno e ai confini. Per aggiornare i frammenti interni, si renderizza un quadrilarero che copre tutto il perimetro del frame buffer tranne un bordo di un pixel. Per aggiornare le celle di confine, si renderizzano quattro primitive linea. Si applicano programmi di frammento separati ai frammenti interni e a quelli di confine. [FIGURA]

IMPLEMENTATION IN FRAGMENT PROGRAMS
Ora che si sanno i passi dell'algoritmo, la rappresentazione dei dati, e come eseguire le slabop, si può scrivere i programmi frammenti che eseguono le computazioni ad ogni cella.

ADVECTION
L'implementazione del programma frammento della advection mostrata in [CODICE] segue quasi esattamente l'equazione 13:
\[
	q(\vec{x}, t + \delta t) = q(\vec{x} - \vec{u}(\vec{x}, t) \delta t, t)
\]

C'è soltanto solo una piccola differenza. Poiché le coordinate della texture non sono nelle stesse unità del dominio della simulazione (le coordinate della texture sono nell'intervallo \([0,N]\), dove \(N\) è la risoluzione della griglia), si deve scalare la velocità nello spazio della griglia. Questo si riflette nel codice Cg con la moltiplicazione della velocità locale per il parametro \texttt{rdx}, che rappresenta il reciproco della scala della griglia \(\delta x\). La modalità di avvolgimento della texture deve essere impostata su CLAMP_TO_EDGE, in modo che il back-tracing al di fuori dell'intervallo \([0,N]\) venga bloccato sui texel di confine. Le condizioni al contorno descritte in seguito aggiornano correttamente questi texel in modo che questa situazioni funzioni correttamente

void advect(float2 coords
            : WPOS,
              // grid coordinates
              out float4 xNew
            : COLOR,
              // advected qty
              uniform float timestep, uniform float rdx,
              // 1 / grid scale
              uniform samplerRECT u,
              // input velocity
              uniform samplerRECT x)
// qty to advect
{
  // follow the velocity field "back in time"
  float2 pos = coords - timestep * rdx * f2texRECT(u, coords);
  // interpolate and write to the output fragment
  xNew = f4texRECTbilerp(x, pos);
}

In this code, the parameter u is the velocity field texture, and x is the field that is to be advected. This could be the velocity or another quantity, such as dye concentration. The function f4texRECTbilerp() is a utility to perform bilinear interpolation of the four texels closest to the texture coordinates passed to it. Because current GPUs do not support automatic bilinear interpolation in floating-point textures, we must implement it with this type of code.

VISCOUS DIFFUSION
With the description of the Jacobi iteration technique given in Section 38.2.4, writing a Jacobi iteration fragment program is simple, as shown in Listing 38-2.

void jacobi(half2 coords
            : WPOS,
              // grid coordinates
              out half4 xNew
            : COLOR,
              // result
              uniform half alpha, uniform half rBeta,
              // reciprocal beta
              uniform samplerRECT x,
              // x vector (Ax = b)
              uniform samplerRECT b)
// b vector (Ax = b)
{
  // left, right, bottom, and top x samples
  half4 xL = h4texRECT(x, coords - half2(1, 0));
  half4 xR = h4texRECT(x, coords + half2(1, 0));
  half4 xB = h4texRECT(x, coords - half2(0, 1));
  half4 xT = h4texRECT(x, coords + half2(0, 1));
  // b sample, from center
  half4 bC = h4texRECT(b, coords);
  // evaluate Jacobi iteration
  xNew = (xL + xR + xB + xT + alpha * bC) * rBeta;
}

Notice that the rBeta parameter is the reciprocal of from Equation 16. To solve the diffusion equation, we set alpha to (x)2/t, rBeta to 1/(4 + (x)2/t), and the x and b parameters to the velocity texture. We then run a number of iterations (usually 20 to 50, but more can be used to reduce the error).

FORCE APPLICATION
The simplest step in our algorithm is computing the acceleration caused by external forces. In the demonstration application found in the accompanying materials, you can apply an impulse to the fluid by clicking and dragging with the mouse. To implement this, we draw a spot into the velocity texture at the position of the click. The color of the spot encodes the direction and magnitude of the impulse: the red channel contains the magnitude in x, and the green channel contains the magnitude in y. The spot is actually a two-dimensional Gaussian "splat."

We use a fragment program to check each fragment's distance from the impulse position. Then we add the quantity c to the color:
\[
	c = \vec{F} \delta t exp \left ( \frac{(x - x_p)^2 + (y - y_p)^2}{r} \right )
\]
Here, \vec{F} is the force computed from the direction and length of the mouse drag, \(r\) is the desired impulse radius, and \((x, y)\) and \((x_p , y_p )\) are the fragment position and impulse (click) position in window coordinates, respectively.

PROJECTION
All'inizio di questa sezione si è appreso che la fase di proiezione è divisa in due operazioni: risolvere la \emph{Poisson-pressure equation} per \(p\), e sottrarre il gradiente di \(p\) dal campo di velocità intermedio. Ciò richiede tre programmi frammento: il già citato programma di iterazione di Jacobi, un programma per computare la divergenza del campo di velocità intermedio, e un programma per sottrarre il gradiente di \(p\) dal campo di velocità intermedio.

Il programma che computa la divergenza mostrato in [CODICE] prende il campo di velocità intermedio come parametro \texttt{w} e la metà del reciproco della scala della griglia come parametro \texttt{halfrdx}, e calcola la divergenza secondo la formula delle differenze finite riportata nella [TABELLA]

void divergence(half2 coords
                : WPOS,
                  // grid coordinates
                  out half4 div
                : COLOR,
                  // divergence
                  uniform half halfrdx,
                  // 0.5 / gridscale
                  uniform samplerRECT w)
// vector field
{
  half4 wL = h4texRECT(w, coords - half2(1, 0));
  half4 wR = h4texRECT(w, coords + half2(1, 0));
  half4 wB = h4texRECT(w, coords - half2(0, 1));
  half4 wT = h4texRECT(w, coords + half2(0, 1));
  div = halfrdx * ((wR.x - wL.x) + (wT.y - wB.y));
}

La divergenza viene scritta in una texture temporanea, che viene poi utilizzata come input per il parametro \texttt{b} del programma di iterazione di Jacobi. Il parametro \texttt{x} del programma Jacobi è impostato sulla texture della pressione, che viene prima cancellata con tutti i valori zero (in altre parole, stiamo usando zero come ipotesi iniziale per il campo di pressione). I parametri \textt{alpha} e \texttt{rBeta} sono impostati rispettivamente a \(-(\delta x)^2\) e \(\frac{1}{4}\).

Per ottenere una buona convergenza della soluzione, in genere si utilizzano da \(40\) a \(80\) iterazioni di Jacobi. La variazione del numero di iterazioni di Jacobi influisce sull'accuratezza della simulazione. Non è una buona idea scendere sotto le \(20\) iterazioni, perché l'errore diventa evidente. L'utilizzo di un numero maggiore di iterazioni consente di ottenere vortici più dettagliati e una maggiore precisione complessiva, ma richiede più tempo di calcolo. Al termine delle iterazioni di Jacobi, si lega la texture del campo di pressione \(p\) nel programma seguente, che calcola il gradiente di \(p\) secondo la definizione della [TABELLA] e lo sottrae dalla texture intermedia del campo di velocità nel parametro \texttt{w}. [CODICE]

void gradient(half2 coords
              : WPOS,
                // grid coordinates
                out half4 uNew
              : COLOR,
                // new velocity
                uniform half halfrdx,
                // 0.5 / gridscale
                uniform samplerRECT p,
                // pressure
                uniform samplerRECT w)
// velocity
{
  half pL = h1texRECT(p, coords - half2(1, 0));
  half pR = h1texRECT(p, coords + half2(1, 0));
  half pB = h1texRECT(p, coords - half2(0, 1));
  half pT = h1texRECT(p, coords + half2(0, 1));
  uNew = h4texRECT(w, coords);
  uNew.xy -= halfrdx * half2(pR - pL, pT - pB);
}

BOUNDARY CONDITIONS
Nella sezione 38.2.4, si è determinato che il "fluido in una scatola" richiede condizioni al contorno di no-slip velocity e pure Neumann pressure. Nella sezione 38.3.2 si è appreso che si possono implementare le condizioni al contorno riservando il perimetro di un pixel della griglia alla memorizzazione dei valori al contorno. I valori vengono aggiornati disegnando primitive di linea sul bordo, utilizzando un programma frammento che imposta i valori in modo appropriato.

Per prima cosa, si deve vedere come la discretizzazione della griglia influisce sul calcolo delle condizioni al contorno. La condizione di no-slip impone che la velocità sia uguale a zero sui confini, e la condizione di pure Neumann pressure richiede che la derivata della pressione normale sia zero ai confini. Il confine è definito sul bordo tra la cella di confine e la cella interna più vicina, ma i valori della griglia sono definiti al centro delle celle. Pertanto, si deve calcolare i valori limite in modo che la media delle due celle adiacenti a qualsiasi bordo soddisfi la condizione limite.

Per il limitie di velocità sul lato sinistro, ad esempio, si ha:
\[
	\frac{\vec{u}_{0,j} + \vec{u}_{1,j}}{2} = 0, \quad \forall j \in [0,N]
\]
dove \(N\) è la risoluzione della griglia. Per soddisfare questa equazione, si deve porre \(\vec{u}_{0,j}\) uguale a \(\vec{u}_{1,j}\). L'equazione della pressione si risolve in modo analogo. Utilizzando l'approsimazione per differenza in avanti della derivata, si ottiene:
\[
	\frac{p_{i,j} - p_{0,j}}{\delta x} = 0
\]
Risolvendo questa equazione per \(p_{0,j}\), si vede che si deve impostare ogni valore limite della pressione sul valore appena all'interno del confine.
Si può utilizzare un semplice programma frammento per i confini della pressione e della velocità, come mostrato in [CODICE]

void boundary(half2 coords
              : WPOS,
                // grid coordinates
                half2 offset
              : TEX1,
                // boundary offset
                out half4 bv
              : COLOR,
                // output value
                uniform half scale,
                // scale parameter
                uniform samplerRECT x)
// state field
{
  bv = scale * h4texRECT(x, coords + offset);
}

La [FIGURA] mostra come funziona questo programma. Il parametro \texttt{x} rappresenta la texture (campo velocità o campo pressione) dal quale si leggono i valori interni. Il parametro \texttt{offset} contiene il corretto offset per le celle interne adiacenti al limite corrente. Il parametro \texttt{coords} contiene la posizione in coordinate della texture del frammento che si sta processando, così aggiungendoci \texttt{offset}, si ottiene il texel adiacente. A ogni confine, si imposta \texttt{offset} per regolare le coordinate della texture sul texel appena all'interno del confine. Per il confine sinistro, si imposta \((1,0)\), in modo da indirizzare il texel appena a destra; per il confine inferiore, si usa \((0,1)\); e così via. Il parametro \texttt{scale} può essere utilzzato per scalare il valore copiato sul confine. Per i confini della velocità, \texttt{scale} è settato a \(-1\), e per la pressione è settato a \(1\), in modo da implementare correttamente le equazioni 17 e 18, rispettivamente.

[FIGURA]


APPLICATIONS
In questa sezione si esplorano una serie di applicazioni delle tecniche di simulazione su GPU discusse in questo capitolo.

SIMULATING LIQUID AND GASES
Il modo più diretto per usare le tecniche di simulazione è simulare un volume continuo di un liquido o un gas. Allo stato attuale , la simulazione rappresenta soltanto la velocità del fluido, che non è molto interessante. \`E più interessante se si inserisce qualcos'altro nel fluido, L'applicazione dimostrativa lo fa mantenendo un campo scalare aggiuntivo. Questo campo rappresenta la concentrazione di colorante trasporato dal fluido. (Trattandosi di una texture RGB, si tratta in realtà di tre campi scalari: uno per ciascuno dei tre colori del colorante). Quantità come questa sono note come \emph{passive scalars} perché sono solo trasportate dal fluido; non influenzano il suo flusso.

Se \(d\) è la concentrazione di colorante, l'evoluzione del campo di colorante è governata dalla seguente equazione:
\[
	\frac{\delta d}{\frac t} = - ( \vec{u} \bullet \nabla ) d
\]
Per simulare come il colorante viene trasportato dal fluido, si applica l'operatore di advection al campo scalare, come si è fatto precedentemente per la velocità. Se si vuole tenere conto anche della diffusione del colorante nel fluido, si aggiunge il termine diffusion:
\[
	\frac{\delta d}{\frac t} = - ( \vec{u} \bullet \nabla ) d + \gamma \nabla^2 d + S
\]
dove \(\gamma\) è il coefficiente di diffusione del colorante in acqua (o qualunque liquido si assuma il fluido sia). Per implementare la diffusione del colorante, si usa la iterazione di Jacobi, come fatto precedentemente per la viscoud diffusion della velocità. Si noti che l'applicazione dimostrativa non esegue effetivamente la diffusione del colorante, perché l'errore numerico nel termine di advection ne causa comunque la diffusione. Si è aggiunto un altro termine all'equazione 20, \(S\). Questo termine rappresenta qualsiasi fonte di colorante. L'applicazione implementa questo termine aggiungendo colorante ovunque si faccia click.

BUOYANCY AND CONVECTION
La temperatura è un fattore importante nel flusso di molti fluidi. Le correnti di convezione sono spesso causate dalle variazioni di densità associate ai cambiamenti di temperatura. Queste correnti influenzano il meteo, gli oceani e laghi, e persino il caffè. Per simulare questi effetti, si deve aggiungere la galleggiabilità (\emph{buoyancy}) alla simulazione.

Il modo più semplice per incorporare il galleggiamento è aggiungere un nuovo campo scalare per la temperatura, \(T\), alla simulazione. Si può quindi inserire un operatore di galleggiamento aggiuntivo che aggiunge forza quando la temperatura locale è superiore a una determinata temperatura ambiente, \(T_0\):
\[
	f_{\text{buoy}} = \sigma ( T - T_0 ) \hat{j}
\]
In questa equazione, \(\hatj}\) è la direzione verticale e \(\sigma\) è un fattore costante di scala. Questa forza può essere implementata in un programma frammento che valuta l'equazione 21 in ogni frammento, scala il risultato per il passo temporale e lo aggiunge alla velocità corrente.

SMOKE AND CLOUDS
Ora si ha quasi tutto ciò che serve per simulare il fumo. Quanto presentato finora è simile alla tecnica di simulazione del fumo introdotta da [FEDKIW]

@inproceedings{10.1145/383259.383260,
author = {Fedkiw, Ronald and Stam, Jos and Jensen, Henrik Wann},
title = {Visual simulation of smoke},
year = {2001},
isbn = {158113374X},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/383259.383260},
doi = {10.1145/383259.383260},
abstract = {In this paper, we propose a new approach to numerical smoke simulation for computer graphics applications. The method proposed here exploits physics unique to smoke in order to design a numerical method that is both fast and efficient on the relatively coarse grids traditionally used in computer graphics applications (as compared to the much finer grids used in the computational fluid dynamics literature). We use the inviscid Euler equations in our model, since they are usually more appropriate for gas modeling and less computationally intensive than the viscous Navier-Stokes equations used by others. In addition, we introduce a physically consistent vorticity confinement term to model the small scale rolling features characteristic of smoke that are absent on most coarse grid simulations. Our model also correctly handles the inter-action of smoke with moving objects.},
booktitle = {Proceedings of the 28th Annual Conference on Computer Graphics and Interactive Techniques},
pages = {15–22},
numpages = {8},
keywords = {Euler equations, Navier-Stokes equations, computational fluid dynamics, participating media, semi-Lagrangian methods, smoke, stable fluids, vorticity confinement},
series = {SIGGRAPH '01}
}

Oltre a calcolare i campi di velocità e pressione, una simulazione di fumo deve mantenere i campi scalari per la densità del fumo \(d\), e la temperatura, \(T\). La densità del fumo è advected dalla velocità del fluido, proprio come il colorante descritto in precedenza. La forza di galleggiamento viene modificata per tenere conto dell'attrazione gravitazionale del fumo denso:
\[
	f_{\text{buoy}} = ( - kd + \sigma ( T - T_0)) \hat{j}
\]
dove \(k\) è un fattore di scala di massa costante.

Aggiungendo una fonte di densità e temperatura del fumo (che potrebbe rappresentare una ciminiera o la punta di una sigaretta) in un determinato punto della griglia, si simula il fumo. L'articolo di Fedwik [FEDWIK] descrive altre due differenze rispetto alla simulazione di base. Utilizzano una griglia sfalsata per migliorare l'accuratezza e aggiungono una forza di confinamento della vorticità per aumentare la quantità di moto vorticoso nel fumo. Entrambe le estensioni sono discusse nella prossima sezione.

Come dimostrato in [HARRIS], è possibile utilizzare una simulazione più complessa per simulare le nuvole sulla GPU. La [FIGURA] mostra una sequenza di fotogrammi di una simulazione di nuvole 2D su GPU. Il simulatore di nuvole combina la simulazione dei fluidi con una simulazione termodinamica (inclusa la galleggiabilità), oltre a una simulazione della condensazione ed evaporazione dell'acqua. 



EXTENSIONS
...
